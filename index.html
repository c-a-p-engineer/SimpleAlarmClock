<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multi Alarm App with Sound/Message Options</title>
  <style>
    /* CSSリセットと基本設定 */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background-color: #1f1f1f;
      color: #e0e0e0;
      font-family: 'Inter', Arial, sans-serif; /* Inter フォントを追加 */
      line-height: 1.6;
      padding: 1rem;
    }
    .container {
      max-width: 800px; /* 最大幅を少し広げる */
      margin: 0 auto;
      padding: 0 1rem;
    }
    header {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    header h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }
    /* カード風デザイン */
    .card {
      background-color: #2b2b2b;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* 影を追加 */
    }
    .card-header {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      border-bottom: 1px solid #444;
      padding-bottom: 0.5rem;
    }
    .card-body {
      margin-bottom: 1rem;
    }
    /* フォームの設定 */
    .form-group {
      margin-bottom: 1rem;
    }
    label {
      display: block;
      margin-bottom: 0.3rem;
      font-weight: bold; /* ラベルを太字に */
    }
    input[type="time"],
    input[type="date"],
    input[type="text"],
    select { /* select要素にもスタイル適用 */
      width: 100%;
      padding: 0.75rem; /* パディング調整 */
      border: 1px solid #444; /* 枠線を追加 */
      border-radius: 4px;
      background-color: #333; /* 背景色変更 */
      color: #e0e0e0; /* 文字色 */
      font-size: 1rem;
    }
    /* チェックボックス用ラベル */
    label.inline-checkbox {
        display: inline-flex; /* チェックボックスとテキストを横並び */
        align-items: center; /* 垂直方向中央揃え */
        margin-bottom: 0;
        font-weight: normal;
        cursor: pointer;
    }
     label.inline-checkbox input[type="checkbox"] {
        width: auto; /* 幅を自動に */
        margin-right: 0.5rem; /* 右にスペース */
     }

    /* ラジオボタンとオプション群 */
    .radio-group, .option-inline {
      margin: 0.5rem 0;
      padding: 0.5rem;
      background-color: #333; /* 背景色 */
      border-radius: 4px;
    }
    .radio-group label,
    .option-inline label {
      margin-right: 1rem;
      cursor: pointer;
      display: inline-block; /* 横並び調整 */
      margin-bottom: 0.5rem; /* 下マージン追加 */
      font-weight: normal; /* ラベル内の太字解除 */
    }
     .option-inline input[type="checkbox"] {
        margin-right: 0.3rem; /* チェックボックス右のスペース */
     }
    /* ボタン */
    .btn {
      background-color: #4CAF50; /* 緑 */
      color: #fff;
      border: none;
      padding: 0.75rem 1.5rem; /* パディング調整 */
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: bold;
      transition: background-color 0.3s ease, transform 0.1s ease;
      margin-top: 0.5rem; /* 上マージン追加 */
    }
    .btn:hover {
      background-color: #45a049;
    }
     .btn:active {
         transform: scale(0.98); /* クリック時の縮小効果 */
     }
    .btn-danger {
      background-color: #e53935; /* 赤 */
    }
    .btn-danger:hover {
      background-color: #d32f2f;
    }
    .btn-primary {
      background-color: #1e88e5; /* 青 */
    }
    .btn-primary:hover {
      background-color: #1565c0;
    }
    /* アラーム発動中の表示 */
    .active-alarm {
      background-color: #c62828; /* 少し暗い赤 */
      padding: 1.5rem; /* パディング調整 */
      border-radius: 8px;
      text-align: center;
      margin-bottom: 1.5rem;
      color: white;
      font-size: 1.2rem;
      font-weight: bold;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    .active-alarm p {
        margin-bottom: 1rem;
    }
    /* テーブルデザイン */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1.5rem;
      background-color: #2b2b2b; /* テーブル背景 */
      table-layout: fixed; /* 列幅の自動調整を防ぐ */
    }
    table, th, td {
      border: 1px solid #444;
      word-wrap: break-word; /* 長いテキストを折り返す */
    }
    th, td {
      padding: 0.75rem; /* パディング調整 */
      text-align: left; /* 左寄せ */
    }
    th {
      background-color: #383838; /* ヘッダー背景 */
      font-weight: bold;
    }
    /* 列幅の調整 (メッセージ内容を広く) */
    th:nth-child(1), td:nth-child(1) { width: 4%; text-align: center;} /* # */
    th:nth-child(2), td:nth-child(2) { width: 8%; } /* 時刻 */
    th:nth-child(3), td:nth-child(3) { width: 8%; } /* タイプ */
    th:nth-child(4), td:nth-child(4) { width: 12%; } /* 詳細 */
    th:nth-child(5), td:nth-child(5) { width: 12%; } /* サウンド */
    th:nth-child(6), td:nth-child(6) { width: 25%; } /* メッセージ内容 */
    th:nth-child(7), td:nth-child(7) { width: 18%; } /* 次回実行 */
    th:nth-child(8), td:nth-child(8) { width: 6%; text-align: center; } /* 有効 */
    th:nth-child(9), td:nth-child(9) { width: 7%; text-align: center; } /* 操作 */

    td {
        vertical-align: middle; /* 中央揃え */
    }
    tr.active {
      background-color: #c62828 !important; /* 発動中の行の背景色 */
      color: white;
      font-weight: bold;
    }
    tr:nth-child(even) {
        background-color: #333; /* 偶数行の背景色 */
    }
    tr:hover {
      background-color: #424242; /* ホバー時の背景色 */
    }
    td:last-child {
        text-align: center; /* 操作ボタン列を中央揃え */
    }
    td input[type="checkbox"] {
        cursor: pointer;
        width: 1.2em;
        height: 1.2em;
    }

    /* レスポンシブ対応（画面幅768px以下の場合） */
    @media (max-width: 768px) {
        table, thead, tbody, th, td, tr {
            display: block; /* テーブルをブロック要素に */
        }
        thead tr {
            position: absolute;
            top: -9999px;
            left: -9999px; /* ヘッダーを隠す */
        }
        tr {
            border: 1px solid #555;
            margin-bottom: 1rem;
            background-color: #333; /* 各行の背景色 */
        }
         tr.active {
             border: 1px solid #e53935;
             background-color: #4d1b1b; /* アクティブ行の背景を少し濃く */
         }
        td {
            border: none;
            border-bottom: 1px solid #444;
            position: relative;
            padding-left: 45%; /* ラベル表示用のスペースを調整 */
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            text-align: right; /* 値を右寄せ */
            white-space: normal;
            width: 100% !important; /* 幅を100%に */
            min-height: 2.5em; /* 最低限の高さを確保 */
            display: flex; /* Flexboxを使用して中央揃えしやすくする */
            align-items: center; /* 垂直方向中央揃え */
            justify-content: flex-end; /* 内容を右端に */
        }
        td:before {
            /* ラベルとして機能するよう疑似要素を設定 */
            position: absolute;
            top: 0; /* 上端に配置 */
            left: 6px;
            width: 40%; /* ラベル幅を調整 */
            padding-right: 10px;
            white-space: nowrap;
            content: attr(data-label); /* data-label属性の内容を表示 */
            font-weight: bold;
            text-align: left; /* ラベルは左寄せ */
            color: #aaa; /* ラベルの色 */
            height: 100%; /* 高さをセルに合わせる */
            display: flex; /* Flexbox */
            align-items: center; /* 垂直方向中央揃え */
        }
        /* 各セルのdata-labelを設定 (JavaScript側で設定) */

        /* 特定のセルの配置調整 */
        td[data-label="#"],
        td[data-label="有効"],
        td[data-label="操作"] {
             justify-content: center; /* 中央揃え */
             padding-left: 0; /* 左パディング不要 */
        }
         td[data-label="有効"] input,
         td[data-label="操作"] button {
             margin-left: auto; /* 右寄せにする */
         }
         td[data-label="#"]:before,
         td[data-label="有効"]:before,
         td[data-label="操作"]:before {
             width: 40%; /* ラベル幅確保 */
         }
         td[data-label="有効"] input {
             margin-left: calc(40% + 10px); /* ラベル分を考慮して配置 */
         }
         td[data-label="操作"] button {
              margin-left: calc(40% + 10px); /* ラベル分を考慮して配置 */
         }


        .btn {
            padding: 0.6rem 1rem;
            font-size: 0.9rem;
        }
    }

    @media (max-width: 480px) {
      header h1 {
        font-size: 1.8rem;
      }
       .card-header {
        font-size: 1.2rem;
      }
       td { font-size: 0.85rem; padding: 0.4rem; padding-left: 40%;}
       td:before { top: 0; left: 4px; width: 35%; }
       td[data-label="有効"] input,
       td[data-label="操作"] button {
            margin-left: calc(35% + 10px);
       }
    }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div class="container">
    <header>
      <h1>Multi Alarm App</h1>
    </header>

    <section id="alarmForm" class="card">
      <div class="card-header">アラーム追加</div>
      <div class="card-body">
        <div class="form-group">
          <label for="alarmTime">時刻入力</label>
          <input type="time" id="alarmTime" required>
        </div>
        <div class="form-group">
            <label for="alarmSound">アラーム音</label>
            <select id="alarmSound">
                <option value="alarm" selected>アラーム音 (ピコピコ)</option>
                <option value="siren">サイレン</option>
                <option value="telephone">電話</option>
                <option value="sos">SOS</option>
                <option value="music">メロディ (きらきら星)</option>
                <option value="">サウンドなし</option>
            </select>
        </div>
        <div class="form-group">
          <label for="alarmMessage">メッセージ内容</label> <input type="text" id="alarmMessage" placeholder="例: 起きる時間です">
           <label class="inline-checkbox" style="margin-top: 0.5rem;">
               <input type="checkbox" id="enableMessage" checked> メッセージを読み上げる
           </label>
        </div>
        <div class="form-group radio-group">
          <label>アラームタイプ：</label>
          <label><input type="radio" name="alarmType" value="daily" checked> 毎日</label>
          <label><input type="radio" name="alarmType" value="weekly"> 曜日指定</label>
          <label><input type="radio" name="alarmType" value="once"> 一回限り</label>
        </div>
        <div class="form-group" id="weeklyOptions" style="display:none;">
          <label>曜日を選択</label>
          <div class="option-inline">
            <label><input type="checkbox" value="0"> 日</label>
            <label><input type="checkbox" value="1"> 月</label>
            <label><input type="checkbox" value="2"> 火</label>
            <label><input type="checkbox" value="3"> 水</label>
            <label><input type="checkbox" value="4"> 木</label>
            <label><input type="checkbox" value="5"> 金</label>
            <label><input type="checkbox" value="6"> 土</label>
          </div>
        </div>
        <div class="form-group" id="onceOptions" style="display:none;">
          <label for="onceDate">日付選択</label>
          <input type="date" id="onceDate">
        </div>
        <button class="btn" id="addAlarmBtn" onclick="addAlarm()">アラーム追加</button>
      </div>
    </section>

    <section id="activeAlarmSection" class="active-alarm" style="display:none;">
      <p id="activeAlarmMessage">アラーム発動中！</p>
      <button class="btn btn-primary" onclick="stopAlarm()">停止</button>
    </section>

    <section id="alarmList" class="card">
      <div class="card-header">設定済みアラーム一覧</div>
      <div class="card-body">
        <table id="alarmsTable">
          <thead>
            <tr>
              <th>#</th>
              <th>時刻</th>
              <th>タイプ</th>
              <th>詳細</th>
              <th>サウンド</th>
              <th>メッセージ内容</th> <th>次回実行</th>
              <th>有効</th>
              <th>操作</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </div>

  <script>
    /*******************
     * グローバル変数 (アラームアプリ用)
     *******************/
    let alarms = [];
    let alarmIdCounter = 0;
    let isAlarmRinging = false;
    const STORAGE_KEY = 'multiAlarmsWithOptions';

    /*******************
     * グローバル変数 (Web Audio API用)
     *******************/
    let audioContext = null;
    let currentSound = { type: null, oscillator: null, gainNode: null, intervalId: null, timeoutIds: [] };
    let isAudioContextInitialized = false;

    // --- DOM要素 ---
    const activeAlarmSection = document.getElementById("activeAlarmSection");
    const activeAlarmMessage = document.getElementById("activeAlarmMessage");
    const alarmsTableBody = document.getElementById("alarmsTable").getElementsByTagName("tbody")[0];
    const alarmSoundSelect = document.getElementById('alarmSound');
    const alarmMessageInput = document.getElementById('alarmMessage');
    const enableMessageCheckbox = document.getElementById('enableMessage');

    // --- 定数 ---
    const SOUND_TYPE_MAP = {
        "alarm": "アラーム音", "siren": "サイレン", "telephone": "電話",
        "sos": "SOS", "music": "メロディ", "": "なし"
    };
    // レスポンシブ用ラベル (ヘッダーと一致させる)
    const TABLE_LABELS = ["#", "時刻", "タイプ", "詳細", "サウンド", "メッセージ内容", "次回実行", "有効", "操作"];

    // --- デスクトップ通知 ---
    if ("Notification" in window && Notification.permission !== "granted") {
      Notification.requestPermission();
    }

    /**************************************************************************
     * Web Audio API 関連の関数 (変更なし)
     **************************************************************************/
    function initAudioContext() { if (isAudioContextInitialized) return true; if (!audioContext) { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext created."); } catch (e) { console.error("Web Audio API is not supported", e); alert("Web Audio API非対応です"); return false; } } if (audioContext.state === 'suspended') { audioContext.resume().then(() => { console.log("AudioContext resumed."); isAudioContextInitialized = true; }).catch(err => console.error("Failed resume:", err)); } else { isAudioContextInitialized = true; } return isAudioContextInitialized; }
    function stopAllSounds() { if (!audioContext || !currentSound.type) return; const now = audioContext.currentTime; console.log(`Stopping Web Audio: ${currentSound.type}`); if (currentSound.intervalId) clearInterval(currentSound.intervalId); currentSound.timeoutIds.forEach(id => clearTimeout(id)); if (currentSound.gainNode) { currentSound.gainNode.gain.cancelScheduledValues(now); try { const gain = currentSound.gainNode.gain.value; currentSound.gainNode.gain.setValueAtTime(gain, now); currentSound.gainNode.gain.linearRampToValueAtTime(0, now + 0.1); } catch(e) { console.warn("Gain error", e); currentSound.gainNode.gain.setValueAtTime(0, now); } } if (currentSound.oscillator) { const oscs = Array.isArray(currentSound.oscillator) ? currentSound.oscillator : [currentSound.oscillator]; oscs.forEach(osc => { try { osc.stop(now + 0.2); } catch (e) { if (e.name !== 'InvalidStateError') console.error("Osc stop error:", e); } }); } const gain = currentSound.gainNode; const osc = currentSound.oscillator; setTimeout(() => { if (gain) gain.disconnect(); if (osc) { const oscs = Array.isArray(osc) ? osc : [osc]; oscs.forEach(o => { try { o.disconnect(); } catch(e) {} }); } console.log("Nodes disconnected."); }, 300); currentSound = { type: null, oscillator: null, gainNode: null, intervalId: null, timeoutIds: [] }; }
    function playSound(soundType) { if (!soundType) { console.log("No sound selected"); return; } if (!isAudioContextInitialized) { console.warn("AudioContext not init"); return; } if (currentSound.type) stopAllSounds(); console.log(`Starting Web Audio: ${soundType}`); currentSound.type = soundType; const now = audioContext.currentTime; currentSound.gainNode = audioContext.createGain(); currentSound.gainNode.gain.setValueAtTime(0.4, now); currentSound.gainNode.connect(audioContext.destination); switch (soundType) { case 'alarm': createAlarmSound(now); break; case 'siren': createSirenSound(now); break; case 'telephone': createTelephoneSound(now); break; case 'sos': createSOSSound(now); break; case 'music': createMusicSound(now); break; default: console.error("Unknown sound:", soundType); currentSound.type = null; } }
    function createAlarmSound(startTime) { const osc = audioContext.createOscillator(); osc.type = 'square'; osc.frequency.setValueAtTime(880, startTime); osc.connect(currentSound.gainNode); osc.start(startTime); currentSound.oscillator = osc; const pD = 0.1, sD = 0.1, iT = pD + sD; function pulse() { if (currentSound.type !== 'alarm' || !isAlarmRinging) { if(currentSound.intervalId) clearInterval(currentSound.intervalId); stopAllSounds(); return; } const now = audioContext.currentTime; if (!currentSound.gainNode) { if(currentSound.intervalId) clearInterval(currentSound.intervalId); return; } try { currentSound.gainNode.gain.cancelScheduledValues(now); currentSound.gainNode.gain.setValueAtTime(0.4, now); currentSound.gainNode.gain.setValueAtTime(0, now + pD); } catch(e) { console.error("Pulse error:", e); if(currentSound.intervalId) clearInterval(currentSound.intervalId); stopAllSounds(); } } pulse(); currentSound.intervalId = setInterval(pulse, iT * 1000); }
    function createSirenSound(startTime) { const osc = audioContext.createOscillator(); osc.type = 'sawtooth'; osc.connect(currentSound.gainNode); osc.start(startTime); currentSound.oscillator = osc; const f1 = 660, f2 = 880, dur = 0.5; function freqChange() { if (currentSound.type !== 'siren' || !isAlarmRinging) { if(currentSound.intervalId) clearInterval(currentSound.intervalId); stopAllSounds(); return; } const now = audioContext.currentTime; if (!currentSound.oscillator) { if(currentSound.intervalId) clearInterval(currentSound.intervalId); return; } try { osc.frequency.cancelScheduledValues(now); osc.frequency.setValueAtTime(f1, now); osc.frequency.linearRampToValueAtTime(f2, now + dur); osc.frequency.setValueAtTime(f2, now + dur); osc.frequency.linearRampToValueAtTime(f1, now + dur * 2); } catch(e) { console.error("Siren freq error:", e); if(currentSound.intervalId) clearInterval(currentSound.intervalId); stopAllSounds(); } } freqChange(); currentSound.intervalId = setInterval(freqChange, dur * 2 * 1000); }
    function createTelephoneSound(startTime) { const o1 = audioContext.createOscillator(), o2 = audioContext.createOscillator(); o1.type = 'sine'; o2.type = 'sine'; o1.frequency.setValueAtTime(440, startTime); o2.frequency.setValueAtTime(480, startTime); o1.connect(currentSound.gainNode); o2.connect(currentSound.gainNode); o1.start(startTime); o2.start(startTime); currentSound.oscillator = [o1, o2]; const rD = 1.0, sD = 2.0, iT = rD + sD; function ring() { if (currentSound.type !== 'telephone' || !isAlarmRinging) { if(currentSound.intervalId) clearInterval(currentSound.intervalId); stopAllSounds(); return; } const now = audioContext.currentTime; if (!currentSound.gainNode) { if(currentSound.intervalId) clearInterval(currentSound.intervalId); return; } try { currentSound.gainNode.gain.cancelScheduledValues(now); currentSound.gainNode.gain.setValueAtTime(0.4, now); currentSound.gainNode.gain.setValueAtTime(0, now + rD); } catch(e) { console.error("Tel ring error:", e); if(currentSound.intervalId) clearInterval(currentSound.intervalId); stopAllSounds(); } } ring(); currentSound.intervalId = setInterval(ring, iT * 1000); }
    function createSOSSound(startTime) { const osc = audioContext.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(600, startTime); osc.connect(currentSound.gainNode); osc.start(startTime); currentSound.oscillator = osc; const dot = 0.15, dash = dot * 3, intra = dot, inter = dot * 3, word = dot * 7; let time = startTime; currentSound.gainNode.gain.setValueAtTime(0, time); function beep(dur, del) { if (currentSound.type !== 'sos' || !isAlarmRinging) return false; if (!currentSound.gainNode) return false; const start = time + del, end = start + dur; try { currentSound.gainNode.gain.setValueAtTime(0.4, start); currentSound.gainNode.gain.setValueAtTime(0, end); } catch(e) { console.error("SOS beep error:", e); stopAllSounds(); return false; } time = end; return true; } let ok = true; if (ok) ok = beep(dot, 0); if (ok) ok = beep(dot, intra); if (ok) ok = beep(dot, intra); if (ok) ok = beep(dash, inter); if (ok) ok = beep(dash, intra); if (ok) ok = beep(dash, intra); if (ok) ok = beep(dot, inter); if (ok) ok = beep(dot, intra); if (ok) ok = beep(dot, intra); if (!ok) return; const loopDelay = time - startTime + word; const timeoutId = setTimeout(() => { if (currentSound.type === 'sos' && isAlarmRinging) createSOSSound(audioContext.currentTime); }, loopDelay * 1000); currentSound.timeoutIds.push(timeoutId); }
    function createMusicSound(startTime) { const osc = audioContext.createOscillator(); osc.type = 'triangle'; osc.connect(currentSound.gainNode); osc.start(startTime); currentSound.oscillator = osc; const tempo = 120, qN = 60 / tempo; const notes = [ { f: 261.63, d: qN }, { f: 261.63, d: qN }, { f: 392.00, d: qN }, { f: 392.00, d: qN }, { f: 440.00, d: qN }, { f: 440.00, d: qN }, { f: 392.00, d: qN * 2 }, ]; let time = startTime; currentSound.gainNode.gain.setValueAtTime(0, time); let ok = true; notes.forEach(n => { if (currentSound.type !== 'music' || !isAlarmRinging || !ok) { ok = false; return; } if (!currentSound.gainNode || !currentSound.oscillator) { ok = false; return; } try { osc.frequency.setValueAtTime(n.f, time); currentSound.gainNode.gain.setValueAtTime(0.3, time); time += n.d; currentSound.gainNode.gain.setValueAtTime(0, time - 0.01); } catch(e) { console.error("Music note error:", e); stopAllSounds(); ok = false; } }); if (!ok) return; const loopDelay = time - startTime + qN; const timeoutId = setTimeout(() => { if (currentSound.type === 'music' && isAlarmRinging) createMusicSound(audioContext.currentTime); }, loopDelay * 1000); currentSound.timeoutIds.push(timeoutId); }

    /**************************************************************************
     * アラームアプリ本体の関数
     **************************************************************************/

    function loadAlarms() { /* (変更なし) */ }
    function saveAlarms() { /* (変更なし) */ }
    document.querySelectorAll('input[name="alarmType"]').forEach(radio => { /* (変更なし) */ });
    function addAlarm() { /* (変更なし) */ }
    function convertDaysToJapanese(days) { /* (変更なし) */ }
    function computeNextAlarmTime(alarm) { /* (変更なし) */ }
    function scheduleAlarm(alarm) { /* (変更なし) */ }

    function updateAlarmsTable() {
      alarmsTableBody.innerHTML = "";
      const sortedAlarms = alarms.slice().sort((a, b) => {
          const aEnabled = a.enabled; const bEnabled = b.enabled;
          const aTime = aEnabled && a.nextTime ? new Date(a.nextTime).getTime() : Infinity;
          const bTime = bEnabled && b.nextTime ? new Date(b.nextTime).getTime() : Infinity;
          if (aTime === Infinity && bTime === Infinity) return 0;
          if (aTime === Infinity) return 1; if (bTime === Infinity) return -1;
          return aTime - bTime;
      });

      sortedAlarms.forEach((alarm, index) => {
        const row = alarmsTableBody.insertRow();
        row.className = alarm.active ? "active" : "";
        if (!alarm.enabled) { row.style.opacity = "0.6"; row.style.fontStyle = "italic"; }

        // ヘルパー関数でセルとdata-labelを追加
        function addCell(content, label) {
            const cell = row.insertCell();
            // HTMLエンティティをエスケープ (メッセージ内容用)
            const escapedContent = typeof content === 'string' ? content.replace(/</g, "&lt;").replace(/>/g, "&gt;") : content;
            cell.innerHTML = escapedContent;
            cell.setAttribute('data-label', label);
            return cell;
        }

        addCell(index + 1, TABLE_LABELS[0]); // #
        addCell(alarm.time, TABLE_LABELS[1]); // 時刻
        let typeText = "";
        if (alarm.mode === "daily") typeText = "毎日";
        else if (alarm.mode === "weekly") typeText = "曜日指定";
        else if (alarm.mode === "once") typeText = "一回限り";
        addCell(typeText, TABLE_LABELS[2]); // タイプ
        let detail = "-";
        if (alarm.mode === "weekly") detail = convertDaysToJapanese(alarm.days);
        else if (alarm.mode === "once") detail = alarm.date;
        addCell(detail, TABLE_LABELS[3]); // 詳細

        // サウンド表示
        const soundDisplay = SOUND_TYPE_MAP[alarm.soundType] || '不明';
        addCell(soundDisplay, TABLE_LABELS[4]); // サウンド

        // --- メッセージ内容表示 (変更箇所) ---
        const messageCell = addCell(alarm.message || "", TABLE_LABELS[5]); // メッセージ内容 (空なら空白)
        if (!alarm.messageEnabled) messageCell.style.color = '#aaa'; // 読み上げ無効なら薄く

        // 次回実行
        const nextTimeText = (alarm.enabled && alarm.nextTime) ? alarm.nextTime.toLocaleString() : "無効";
        const nextTimeCell = addCell(nextTimeText, TABLE_LABELS[6]); // 次回実行
         if (!alarm.enabled) nextTimeCell.style.color = '#aaa';

        // 有効／無効切替
        const enableCell = addCell(`<input type="checkbox" title="アラームの有効/無効を切り替え" id="toggle_${alarm.id}" onchange="toggleAlarmState(${alarm.id})" ${alarm.enabled ? "checked" : ""}>`, TABLE_LABELS[7]); // 有効
        enableCell.style.textAlign = 'center';

        // 操作（削除ボタン）
        const actionCell = addCell(`<button class="btn btn-danger" style="padding: 0.3rem 0.6rem; font-size: 0.8rem;" onclick="removeAlarm(${alarm.id})">削除</button>`, TABLE_LABELS[8]); // 操作
        actionCell.style.textAlign = 'center';
      });
    }

    function toggleAlarmState(id) { initAudioContext(); const alarm = alarms.find(a => a.id === id); if (!alarm) return; const checkbox = document.getElementById("toggle_" + id); alarm.enabled = checkbox.checked; if (alarm.enabled) { scheduleAlarm(alarm); } else { if (alarm.timerId) { clearTimeout(alarm.timerId); alarm.timerId = null; } alarm.nextTime = null; } saveAlarms(); updateAlarmsTable(); }
    function removeAlarm(id) { const idx = alarms.findIndex(a => a.id === id); if (idx !== -1) { if (alarms[idx].timerId) clearTimeout(alarms[idx].timerId); alarms.splice(idx, 1); updateAlarmsTable(); saveAlarms(); } }
    function repeatSpeakAlarm(message) { if (!isAlarmRinging || !('speechSynthesis' in window)) return; speechSynthesis.cancel(); let u = new SpeechSynthesisUtterance(message); u.lang = "ja-JP"; u.rate = 1.0; u.pitch = 1.0; u.onend = function() { if (isAlarmRinging) { setTimeout(() => { if (isAlarmRinging) speechSynthesis.speak(u); }, 500); } }; u.onerror = function(e) { console.error('SpeechSynthesis Error:', e.error); isAlarmRinging = false; stopAlarm(); }; speechSynthesis.speak(u); }
    function triggerAlarm(id) { /* (変更なし) */ }
    function stopAlarm() { /* (変更なし) */ }

    /*******************
     * 初期化処理
     *******************/
    function initializeAudioOnFirstInteraction() { /* (変更なし) */ }
    document.body.addEventListener('click', initializeAudioOnFirstInteraction, true);
    document.body.addEventListener('touchstart', initializeAudioOnFirstInteraction, true);

    window.addEventListener("load", () => {
      loadAlarms();
      console.log("アラームアプリ(一覧表示改善)が読み込まれました。");
    });

  </script>
</body>
</html>
